---
layout: post
title: "Optimizer 만들기 7"
category: 만들기
---

# 서론

저번엔 드디어 SGD의 구현을 완료했다.

어느 정도 괜찮게 돌아가는 것 같으니, 이젠 다른 Optimizer들을 구현하자.

# Momentum

모멘텀부터 생겨나는 문제가 있다.

현재 모멘텀 (혹은 다른 Optimizer에서 쓰이는 다른 값)을 저장해둬야 한다는 점이다.

내부에 무슨 딕셔너리같은 무언가를 만들어서 해결해볼 수 있지 않을까.

파이썬의 딕셔너리의 key가 되려면 hash가 돼야 한다.

Hash는 `__hash__`를 구현해주면 된다. 해시 충돌은 상관 없다.

[한 stackoverflow 글에서 hash(str())을 추천한다.](https://stackoverflow.com/questions/4950155/objects-as-keys-in-python-dictionaries) 이 대로 구현해주자.

라고 하고 나서 생각해봤더니 문제가 하나 있다. Tensor의 이름은 신경쓰지 않아야 한다는 점이다. 계속 바뀔 수 있으니까.

계산 그래프의 func의 hash(str())으로 했다. 해시 충돌이 많이 날 것 같지만 일단은 넘어가자.

그리고 이번에도 NaN은 어김없이 보인다. 뭐가 문제일까.

일단 어이 없는 실수 하나. 이걸 고치면 아마 NaN은 나오지 않을꺼다.

하지만 grad가 전혀 적용되지 않는 문제도 있다. 이건 직접 출력해서 확인해본거다.

Optimzer가 계속 매번 초기화되고 있다. 그러니까 안되는 모양이다.

코드 반복을 감수하고 Optimzer를 loop 바깥쪽으로 뺐다. loss가 크게 요동치는게 아무래도 제대로 적용된 것 같다.

막 엄청 좋은 결과를 보여주는건 아니지만, 일단은 Ground Truth로 생각하고 있는 PyTorch와 같은 결과를 낸다. 이거면 된게 아닐까.

또 겸사겸사 trainable로 지정해준 것만 train가능하게 바꿨다. 아무래도 그게 속도를 조금 많이 잡아먹는 기분이다.

# NAG

시간이 여유가 좀 있기도 하고 거의 Momentum과 비슷하기도 하니까 NAG도 추가로 만들어주자.

정확한 알고리즘은 PyTorch의 것을 따르고 있다. 내가 이전에 공부했던 알고리즘과는 조금 다른 모양이지만.

생각보다 잘 안된다. NAG는 다음에 마저 하는걸로 하자.
